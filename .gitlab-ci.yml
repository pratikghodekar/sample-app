build:
    stage: build
    image: docker:19.03.12
    
    variables:
        # When using dind service, you must instruct Docker to talk with
        # the daemon started inside of the service. The daemon is available
        # with a network connection instead of the default
        # /var/run/docker.sock socket.
        DOCKER_HOST: tcp://docker:2376
        #
        # The 'docker' hostname is the alias of the service container as described at
        # https://docs.gitlab.com/ee/ci/services/#accessing-the-services.
        # If you're using GitLab Runner 12.7 or earlier with the Kubernetes executor and Kubernetes 1.6 or earlier,
        # the variable must be set to tcp://localhost:2376 because of how the
        # Kubernetes executor connects services to the job container
        # DOCKER_HOST: tcp://localhost:2376
        #
        # Specify to Docker where to create the certificates. Docker
        # creates them automatically on boot, and creates
        # `/certs/client` to share between the service and job
        # container, thanks to volume mount from config.toml
        DOCKER_TLS_CERTDIR: "/certs"
        # These are usually specified by the entrypoint, however the
        # Kubernetes executor doesn't run entrypoints
        # https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4125
        DOCKER_TLS_VERIFY: 1
        DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"

    tags:
        - mirantis-build
        - linux
    
    services:
        - docker:19.03.12-dind

    before_script:
        - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY  

    script:
        - printenv
        - docker build --build-arg COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA}${CI_PIPELINE_ID} -t ${CI_DOCKER_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}${CI_PIPELINE_ID} -t ${CI_DOCKER_REGISTRY_IMAGE}:latest .
        - docker push ${CI_DOCKER_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}${CI_PIPELINE_ID}
        - docker push ${CI_DOCKER_REGISTRY_IMAGE}:latest
    rules:
        - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == "dev"
        - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == "qa"

deploy:
    stage: deploy
    before_script:
        - 'which ssh-agent || ( apt-get update -qy && apt-get install openssh-client -qqy )'
        - eval `ssh-agent -s`
        - echo "${SSH_PRIVATE_KEY}" | tr -d '\r' | ssh-add - > /dev/null # add ssh ke
        - mkdir -p ~/.ssh
        - chmod 700 ~/.ssh        
        - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'
        - git config --global user.email "devops@mirantis.com"
        - git config --global user.name "Mirantis DevOps"

    script:
        - git clone ${CI_ARGOCD_GIT_REPO}
        - cd argocd-autopilot-app
        - >
           sed -i "s/newTag.*/newTag: \"${CI_COMMIT_SHORT_SHA}${CI_PIPELINE_ID}\"/" apps/hello-world/overlays/${CI_COMMIT_REF_NAME}/kustomization.yaml
        - git add apps/hello-world/overlays/${CI_COMMIT_REF_NAME}/kustomization.yaml
        - git commit -m "updated ${CI_COMMIT_REF_NAME} tag to ${CI_COMMIT_SHORT_SHA}${CI_PIPELINE_ID}"
        - git remote add github ${CI_ARGOCD_GIT_REPO}
        - git push github main
    rules:
        - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == "dev"
        - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_REF_NAME == "qa"
